import os
import re
import socket
import sys
import urllib

import RBUtilities

class Repository(object):
    """Base Repository class
    
    Repository is responsible for dealing with local repositories. It collects
    and stores info about the repository (location, SCM type, etc.), as well as
    creating diffs.
    """

    url = None
    util = None

    def __init__(self, url=None, util=None):
        self.url = url
        self.util = util

    def get_info(self):
        """Returns information about the repository

        This is the base version, and doesn't return anything
        """
        return None

    def diff(self, args):
        """Returns the generated diff and optional parent diff for this
        repository.

        The returned tuple is (diff_string, parent_diff_string)
        """
        return (None, None)


class CVSRepository(Repository):
    """Implementation of Repository for CVS repositories"""

    def get_info(self):
        """Returns information about the repository
        
        This is an actual implementation that returns info about the cvs repo
        """

        if not self.util.check_install("cvs"):
            return None

        cvsroot_path = os.path.join("CVS", "Root")

        if not os.path.exists(cvsroot_path):
            return None

        fp = open(cvsroot_path, "r")
        repository_path = fp.read().strip()
        fp.close()

        i = repository_path.find("@")
        if i != -1:
            repository_path = repository_path[i + 1:]

        i = repository_path.find(":")

        if i != -1:
            host = repository_path[:i]
            try:
                canon = socket.getfqdn(host)
                repository_path = repository_path.replace('%s:' % host,
                                                          '%s:' % canon)
            except socket.error, msg:
                #debug("failed to get fqdn for %s, msg=%s" % (host, msg))
                pass

        return RepositoryInfo(path=repository_path)

    def diff(self, files):
        """Performs a diff across all modified files in a CVS repository.

        CVS repositories do not support branches of branches in a way that
        makes parent diffs possible, so we never return a parent diff
        (the second value in the tuple).
        """
        return (self.do_diff(files), None)

    def do_diff(self, params):
        """Actual implementation for creating diffs
        
        Performs the actual diff operation through cvs diff, handling
        fake errors generated by CVS.
        """
        # Diff returns "1" if differences were found.
        return self.util.execute(["cvs", "diff", "-uN"] + params,
                        extra_ignore_errors=(1,))


class ClearCaseRepository(Repository):
    """An implementation of Repository for ClearCase repositories"""
    
    viewinfo = ""
    viewtype = "snapshot"

    def get_info(self):
        """Returns information about the repository
        
        This is an actual implementation that returns info about the CC repo
        """

        if not self.util.check_install('cleartool help'):
            return None

        # We must be running this from inside a view.
        # Otherwise it doesn't make sense.
        self.viewinfo = self.util.execute(["cleartool", "pwv", "-short"])

        if self.viewinfo.startswith('\*\* NONE'):
            return None

        # Returning the hardcoded clearcase root path to match the server
        #   respository path.
        # There is no reason to have a dynamic path unless you have
        #   multiple clearcase repositories. This should be implemented.
        return RepositoryInfo(path=self.url,
                              base_path=self.url,
                              supports_parent_diffs=False)

    def diff(self, files):
        """Creates a diff
        
        Performs a diff of the specified file and its previous version.
        """
        # We must be running this from inside a view.
        # Otherwise it doesn't make sense.
        return self.do_diff(self.get_extended_namespace(files))

    def do_diff(self, params):
        # Diff returns "1" if differences were found.
        # Add the view name and view type to the description
        o = []
        Feol = False

        while len(params) > 0:
            # Read both original and modified files.
            onam = params.pop(0)
            mnam = params.pop(0)

            file_data = []
            do_rem = False

            # If the filename length is greater than 254 char for windows,
            #   we copied the file to a temp file
            #   because the open will not work for path greater than 254.
            # This is valid for the original and
            #   modified files if the name size is > 254.
            for filenam in (onam, mnam):

                if cpath.exists(filenam) and self.viewtype == "dynamic":
                    do_rem = False
                    fn = filenam
                elif len(filenam) > 254 or self.viewtype == "snapshot":
                    fn = self.get_filename_hash(filenam)
                    fn = cpath.join(tempfile.gettempdir(), fn)
                    do_rem = True

                if cpath.isdir(filenam):
                    content = [
                        '%s\n' % s
                        for s in sorted(os.listdir(filenam))
                    ]
                    file_data.append(content)
                else:
                    fd = open(cpath.normpath(fn))
                    fdata = fd.readlines()
                    fd.close()
                    file_data.append(fdata)
                    # If the file was temp, it should be removed.
                    if do_rem:
                        os.remove(filenam)

            modi = file_data.pop()
            orig = file_data.pop()

            # For snapshot views, the local directories must be removed because
            #   they will break the diff on the server. Just replacing
            #   everything before the view name (including the view name) for
            #   vobs do the work.
            if (self.viewtype == "snapshot"
                and (sys.platform.startswith('win')
                  or sys.platform.startswith('cygwin'))):
                    vinfo = self.viewinfo.rstrip("\r\n")
                    mnam = "c:\\\\vobs" + mnam[mnam.rfind(vinfo) + len(vinfo):]
                    onam = "c:\\\\vobs" + onam[onam.rfind(vinfo) + len(vinfo):]

            # Call the diff lib to generate a diff.
            # The dates are bogus, since they don't natter anyway.
            # The only thing is that two spaces are needed to the server
            #   so it can identify the heades correctly.
            diff = difflib.unified_diff(orig, modi, onam, mnam,
               '  2002-02-21 23:30:39.942229878 -0800',
               '  2002-02-21 23:30:50.442260588 -0800', lineterm=' \n')
            # Transform the generator output into a string output
            #   Use a comprehension instead of a generator,
            #   so 2.3.x doesn't fail to interpret.
            diffstr = ''.join([str(l) for l in diff])

            # Workaround for the difflib no new line at end of file
            #   problem.
            if not diffstr.endswith('\n'):
                diffstr = diffstr + ("\n\\ No newline at end of file\n")

            o.append(diffstr)

        ostr = ''.join(o)
        return (ostr, None)  # diff, parent_diff (not supported)


class GitRepository(Repository):
    """An implementation of Repository for Git repositories"""

    def _strip_heads_prefix(self, ref):
        """ Strips prefix from ref name, if possible """
        return re.sub(r'^refs/heads/', '', ref)

    def get_info(self):
        """Returns information about the repository
            
        This is an actual implementation that returns info about the Git repo
        """

        if not self.util.check_install('git --help'):
            return None

        git_dir = self.util.execute(["git", "rev-parse", "--git-dir"],
                          ignore_errors=True).strip()

        if git_dir.startswith("fatal:") or not os.path.isdir(git_dir):
            return None

        # post-review in directories other than the top level of
        # of a work-tree would result in broken diffs on the server
        os.chdir(os.path.dirname(os.path.abspath(git_dir)))

        self.head_ref = self.util.execute(['git', 'symbolic-ref', \
                                            '-q', 'HEAD']).strip()

        # We know we have something we can work with. Let's find out
        # what it is. We'll try SVN first.
        data = self.util.execute(["git", "svn", "info"], ignore_errors=True)

        m = re.search(r'^Repository Root: (.+)$', data, re.M)

        if m:
            path = m.group(1)
            m = re.search(r'^URL: (.+)$', data, re.M)

            if m:
                base_path = m.group(1)[len(path):] or "/"
                m = re.search(r'^Repository UUID: (.+)$', data, re.M)

                if m:
                    uuid = m.group(1)
                    self.type = "svn"
                    self.upstream_branch = options.parent_branch or 'master'

                    return SvnRepositoryInfo(path=path, base_path=base_path,
                                             uuid=uuid,
                                             supports_parent_diffs=True)
        else:
            # Versions of git-svn before 1.5.4 don't (appear to) support
            # 'git svn info'.  If we fail because of an older git install,
            # here, figure out what version of git is installed and give
            # the user a hint about what to do next.
            version = self.util.execute(["git", "svn", "--version"], \
                                        ignore_errors=True)
            version_parts = re.search('version (\d+)\.(\d+)\.(\d+)',
                                      version)
            svn_remote = self.util.execute(["git", "config", "--get",
                                  "svn-remote.svn.url"], ignore_errors=True)

            if (version_parts and
                not self.is_valid_version((int(version_parts.group(1)),
                                           int(version_parts.group(2)),
                                           int(version_parts.group(3))),
                                          (1, 5, 4)) and
                svn_remote):
                die("Your installation of git-svn must be upgraded to " + \
                    "version 1.5.4 or later")

        # Okay, maybe Perforce.
        # TODO

        # Nope, it's git then.
        # Check for a tracking branch and determine merge-base
        short_head = self._strip_heads_prefix(self.head_ref)
        merge = self.util.execute(['git', 'config', '--get',
                         'branch.%s.merge' % short_head],
                        ignore_errors=True).strip()
        remote = self.util.execute(['git', 'config', '--get',
                          'branch.%s.remote' % short_head],
                         ignore_errors=True).strip()

        merge = self._strip_heads_prefix(merge)
        self.upstream_branch = ''

        if remote and remote != '.' and merge:
            self.upstream_branch = '%s/%s' % (remote, merge)

        self.upstream_branch, origin_url = self.get_origin( \
                                self.upstream_branch, True)

        if not origin_url or origin_url.startswith("fatal:"):
            self.upstream_branch, origin_url = self.get_origin()

        self.url = origin_url.rstrip('/')

        if self.url:
            self.type = "git"
            return RepositoryInfo(path=self.url, base_path='',
                                  supports_parent_diffs=True)

        return None

    def get_origin(self, default_upstream_branch=None, ignore_errors=False):
        """Get upstream remote origin from options or parameters.

        Returns a tuple: (upstream_branch, remote_url)
        """
        #upstream_branch = options.tracking or default_upstream_branch or
        upstream_branch = default_upstream_branch or \
                          'origin/master'
        upstream_remote = upstream_branch.split('/')[0]
        origin_url = self.util.execute(["git", "config", \
                                    "remote.%s.url" % upstream_remote], \
                                    ignore_errors=ignore_errors)

        return (upstream_branch, origin_url.rstrip('\n'))

    def is_valid_version(self, actual, expected):
        """
        Takes two tuples, both in the form:
            (major_version, minor_version, micro_version)
        Returns true if the actual version is greater than or equal to
        the expected version, and false otherwise.
        """
        return (actual[0] > expected[0]) or \
               (actual[0] == expected[0] and actual[1] > expected[1]) or \
               (actual[0] == expected[0] and actual[1] == expected[1] and \
                actual[2] >= expected[2])

    def scan_for_server(self, repository_info):
    """Scans for a git server
    
    Scans looking for a Git server, or failing that an SVN server
    """
    
        # Scan first for dot files, since it's faster and will cover the
        # user's $HOME/.reviewboardrc
        server_url = super(GitRepository, self).scan_for_server( \
                                                            repository_info)
        if server_url:
            return server_url

        # TODO: Maybe support a server per remote later? Is that useful?
        self.url = self.util.execute(["git", "config", "--get", \
                            "reviewboard.url"], ignore_errors=True).strip()

        if self.url:
            return self.url

        if self.type == "svn":
            # Try using the reviewboard:url property on the SVN repo, if it
            # exists.
            prop = SVNRepository(self.url, \
                        self.util).scan_for_server_property(repository_info)

            if prop:
                return prop

        return None

    def diff(self, args):
        """Creates a diff
        
        Performs a diff across all modified files in the branch, taking into
        account a parent branch.
        """
        #parent_branch = options.parent_branch

        self.merge_base = self.util.execute(["git", "merge-base", \
                                self.upstream_branch, self.head_ref]).strip()

        if parent_branch:
            diff_lines = self.make_diff(parent_branch)
            parent_diff_lines = self.make_diff(self.merge_base, parent_branch)
        else:
            diff_lines = self.make_diff(self.merge_base, self.head_ref)
            parent_diff_lines = None

        if options.guess_summary and not options.summary:
            options.summary = self.util.execute(["git", "log", \
                "--pretty=format:%s", "HEAD^.."], ignore_errors=True).strip()

        if options.guess_description and not options.description:
            options.description = s elf.util.execute( \
                ["git", "log", "--pretty=format:%s%n%n%b", \
                 (parent_branch or self.merge_base) + ".."], \
                ignore_errors=True).strip()

        return (diff_lines, parent_diff_lines)

    def make_diff(self, ancestor, commit=""):
        """
        Performs a diff on a particular branch range.
        """
        rev_range = "%s..%s" % (ancestor, commit)

        if self.type == "svn":
            diff_lines = self.util.execute(["git", "diff", "--no-color", \
                                        "--no-prefix", "-r", "-u", \
                                        rev_range], split_lines=True)
            return self.make_svn_diff(ancestor, diff_lines)
        elif self.type == "git":
            return self.util.execute(["git", "diff", "--no-color", \
                                    "--full-index", rev_range])

        return None

    def make_svn_diff(self, parent_branch, diff_lines):
        """Creates a diff for an svn server
        
        Formats the output of git diff such that it's in a form that
        svn diff would generate. This is needed so the SVNTool in Review
        Board can properly parse this diff.
        """
        rev = self.util.execute(["git", "svn", "find-rev", \
                                    parent_branch]).strip()

        if not rev:
            return None

        diff_data = ""
        filename = ""
        revision = ""
        newfile = False

        for line in diff_lines:

            if line.startswith("diff "):
                # Grab the filename and then filter this out.
                # This will be in the format of:
                #
                # diff --git a/path/to/file b/path/to/file
                info = line.split(" ")
                diff_data += "Index: %s\n" % info[2]
                diff_data += "=" * 67
                diff_data += "\n"
            elif line.startswith("index "):
                # Filter this out.
                pass
            elif line.strip() == "--- /dev/null":
                # New file
                newfile = True
            elif line.startswith("--- "):
                newfile = False
                diff_data += "--- %s\t(revision %s)\n" % \
                             (line[4:].strip(), rev)
            elif line.startswith("+++ "):
                filename = line[4:].strip()
                if newfile:
                    diff_data += "--- %s\t(revision 0)\n" % filename
                    diff_data += "+++ %s\t(revision 0)\n" % filename
                else:
                    # We already printed the "--- " line.
                    diff_data += "+++ %s\t(working copy)\n" % filename
            elif line.startswith("new file mode"):
                # Filter this out.
                pass
            elif line.startswith("Binary files "):
                # Add the following so that we know binary files were
                # added/changed
                diff_data += "Cannot display: file marked as a binary type.\n"
                diff_data += "svn:mime-type = application/octet-stream\n"
            else:
                diff_data += line

        return diff_data

    def diff_between_revisions(self, revision_range, args, repository_info):
        """Perform a diff between two arbitrary revisions"""
        if ":" not in revision_range:
            # only one revision is specified
#            if options.guess_summary and not options.summary:
#                options.summary =self.util.execute(
#                  ["git", "log", "--pretty=format:%s", revision_range + ".."],
#                    ignore_errors=True).strip()
#
#            if options.guess_description and not options.description:
#                options.description =self.util.execute(
#            ["git", "log", "--pretty=format:%s%n%n%b", revision_range + ".."],
#                    ignore_errors=True).strip()

            return self.make_diff(revision_range)
        else:
            r1, r2 = revision_range.split(":")

            #if options.guess_summary and not options.summary:
            #    options.summary = execute(
            #        ["git", "log", "--pretty=format:%s", "%s..%s" % (r1, r2)],
            #        ignore_errors=True).strip()

            #if options.guess_description and not options.description:
            #    options.description = execute(
            #        ["git", "log", "--pretty=format:%s%n%n%b", "%s..%s" %
                        #(r1, r2)], ignore_errors=True).strip()

            return self.make_diff(r1, r2)


class MercurialRepository(Repository):
    """An implementation of Repository for Mercurial repositories"""

    url = None
    util = None

    def __init__(self, url=None, util=None):
        self.url = url
        self.util = util
        self.hgrc = {}
        self._type = 'hg'
        self._hg_root = ''
        self._remote_path = ()
        self._hg_env = {
            'HGRCPATH': os.devnull,
            'HGPLAIN': '1',
        }

        # `self._remote_path_candidates` is an ordered set of hgrc
        # paths that are checked if `parent_branch` option is not given
        # explicitly.  The first candidate found to exist will be used,
        # falling back to `default` (the last member.)
        self._remote_path_candidates = ['reviewboard', 'origin', 'parent',
                                        'default']

    def get_info(self):
        """Returns information about the repository
        
        This is an actual implementation that returns info about the hg repo
        """

        if not self.util.check_install('hg --help'):
            return None

        self._load_hgrc()

        if not self.hg_root:
            # hg aborted => no mercurial repository here.
            return None

        svn_info = self.util.execute(["hg", "svn", "info"], ignore_errors=True)

        if (not svn_info.startswith('abort:') and
            not svn_info.startswith("hg: unknown command") and
            not svn_info.lower().startswith('not a child of')):
            return self._calculate_hgsubversion_repository_info(svn_info)

        self._type = 'hg'

        path = self.hg_root
        base_path = '/'

        if self.hgrc:
            self._calculate_remote_path()

            if self._remote_path:
                path = self._remote_path[1]
                base_path = ''

        return RepositoryInfo(path=path, base_path=base_path,
                              supports_parent_diffs=True)

    def _calculate_remote_path(self):
        """Calculate the remote path for the repository
    
        Calculates the correct remote path for the mercurial repository
        """

        for candidate in self._remote_path_candidates:

            rc_key = 'paths.%s' % candidate

            if (not self._remote_path and self.hgrc.get(rc_key)):
                self._remote_path = (candidate, self.hgrc.get(rc_key))
                #debug('Using candidate path %r: %r' % self._remote_path)

                return

    def _calculate_hgsubversion_repository_info(self, svn_info):
        self._type = 'svn'
        m = re.search(r'^Repository Root: (.+)$', svn_info, re.M)

        if not m:
            return None

        path = m.group(1)
        m2 = re.match(r'^(svn\+ssh|http|https|svn)://([-a-zA-Z0-9.]*@)(.*)$',
                        path)
        if m2:
            path = '%s://%s' % (m2.group(1), m2.group(3))

        m = re.search(r'^URL: (.+)$', svn_info, re.M)

        if not m:
            return None

        base_path = m.group(1)[len(path):] or "/"
        return RepositoryInfo(path=path, base_path=base_path,
                              supports_parent_diffs=True)

    @property
    def hg_root(self):

        if not self._hg_root:
            root = self.util.execute(['hg', 'root'], env=self._hg_env,
                           ignore_errors=True)

            if not root.startswith('abort:'):
                self._hg_root = root.strip()
            else:
                self._hg_root = '.'

        return self._hg_root

    def _load_hgrc(self):
        for line in self.util.execute(['hg', 'showconfig'], split_lines=True):
            key, value = line.split('=', 1)
            self.hgrc[key] = value.strip()

    def extract_summary(self, revision):
        """
        Extracts the first line from the description of the given changeset.
        """
        return self.util.execute(['hg', 'log', '-r%s' % revision, '--template',
                        r'{desc|firstline}\n'], env=self._hg_env)

    def extract_description(self, rev1, rev2):
        """
        Extracts all descriptions in the given revision range and concatenates
        them, most recent ones going first.
        """
        numrevs = len(self.util.execute([
            'hg', 'log', '-r%s:%s' % (rev2, rev1),
            '--follow', '--template', r'{rev}\n'], env=self._hg_env
        ).strip().split('\n'))

        return self.util.execute(['hg', 'log', '-r%s:%s' % (rev2, rev1),
                        '--follow', '--template',
                        r'{desc}\n\n', '--limit',
                        str(numrevs - 1)], env=self._hg_env).strip()

    def diff(self, files):
        """
        Performs a diff across all modified files in a Mercurial repository.
        """
        files = files or []

        if self._type == 'svn':
            return self._get_hgsubversion_diff(files)
        else:
            return self._get_outgoing_diff(files)

    def _get_hgsubversion_diff(self, files):
        parent = self.util.execute(['hg', 'parent', '--svn', '--template',
                          '{node}\n']).strip()

        # if options.parent_branch:
        #    parent = options.parent_branch

        #if options.guess_summary and not options.summary:
        #    options.summary = self.extract_summary(".")

        #if options.guess_description and not options.description:
        #    options.description = self.extract_description(parent, ".")

        return (self.util.execute(["hg", "diff", "--svn", \
                                    '-r%s:.' % parent]), None)

    def _get_outgoing_diff(self, files):
        """
        When working with a clone of a Mercurial remote, we need to find
        out what the outgoing revisions are for a given branch.  It would
        be nice if we could just do `hg outgoing --patch <remote>`, but
        there are a couple of problems with this.

        For one, the server-side diff parser isn't yet equipped to filter out
        diff headers such as "comparing with..." and "changeset: <rev>:<hash>".
        Another problem is that the output of `outgoing` potentially includes
        changesets across multiple branches.

        In order to provide the most accurate comparison between one's local
        clone and a given remote -- something akin to git's diff command syntax
        `git diff <treeish>..<treeish>` -- we have to do the following:

            - get the name of the current branch
            - get a list of outgoing changesets, specifying a custom format
            - filter outgoing changesets by the current branch name
            - get the "top" and "bottom" outgoing changesets
            - use these changesets as arguments to `hg diff -r <rev> -r <rev>`


        Future modifications may need to be made to account for odd cases like
        having multiple diverged branches which share partial history -- or we
        can just punish developers for doing such nonsense :)
        """
        files = files or []

        remote = self._remote_path[0]

        #if not remote and options.parent_branch:
        #    remote = options.parent_branch

        current_branch = self.util.execute(['hg', 'branch'], \
                                            env=self._hg_env).strip()

        outgoing_changesets = \
            self._get_outgoing_changesets(current_branch, remote)

        top_rev, bottom_rev = \
            self._get_top_and_bottom_outgoing_revs(outgoing_changesets)

        full_command = ['hg', 'diff', '-r', str(bottom_rev), '-r',
                        str(top_rev)] + files

        return (self.util.execute(full_command, env=self._hg_env), None)

    def _get_outgoing_changesets(self, current_branch, remote):
        """
        Given the current branch name and a remote path, return a list
        of outgoing changeset numbers.
        """
        outgoing_changesets = []
        raw_outgoing = self.util.execute(['hg', '-q', 'outgoing', '--template',
                                'b:{branches}\nr:{rev}\n\n', remote],
                               env=self._hg_env)

        for pair in raw_outgoing.split('\n\n'):

            if not pair.strip():
                continue

            branch, rev = pair.strip().split('\n')

            branch_name = branch[len('b:'):].strip()
            branch_name = branch_name or 'default'
            revno = rev[len('r:'):]

            if branch_name == current_branch and revno.isdigit():
                #debug('Found outgoing changeset %s for branch %r'
                 #     % (revno, branch_name))
                outgoing_changesets.append(int(revno))

        return outgoing_changesets

    def _get_top_and_bottom_outgoing_revs(cls, outgoing_changesets):
        # This is a classmethod rather than a func mostly just to keep the
        # module namespace clean.  Pylint told me to do it.
        top_rev = max(outgoing_changesets)
        bottom_rev = min(outgoing_changesets)
        bottom_rev = max([0, bottom_rev - 1])

        return top_rev, bottom_rev

    # postfix decorators to stay pre-2.5 compatible
    _get_top_and_bottom_outgoing_revs = \
        classmethod(_get_top_and_bottom_outgoing_revs)

    def diff_between_revisions(self, revision_range, args, repository_info):
        """
        Performs a diff between 2 revisions of a Mercurial repository.
        """

        if self._type != 'hg':
            raise NotImplementedError

        r1, r2 = revision_range.split(':')

        #if options.guess_summary and not options.summary:
        #    options.summary = self.extract_summary(r2)

        #if options.guess_description and not options.description:
         #   options.description = self.extract_description(r1, r2)

        return self.util.execute(["hg", "diff", "-r", r1, "-r", r2],
                       env=self._hg_env)

    def scan_for_server(self, repository_info):
        # Scan first for dot files, since it's faster and will cover the
        # user's $HOME/.reviewboardrc
        server_url = \
            super(MercurialRepository, self).scan_for_server(repository_info)

        if not server_url and self.hgrc.get('reviewboard.url'):
            server_url = self.hgrc.get('reviewboard.url').strip()

        if not server_url and self._type == "svn":
            # Try using the reviewboard:url property on the SVN repo, if it
            # exists.
            prop = SVNRepository().scan_for_server_property(repository_info)

            if prop:
                return prop

        return server_url


class PerforceRepository(Repository):
    """An implementation of Repository for Perforce repositories"""

    def get_info(self):
        """Returns information about the repository
        
        This is an actual implementation that returns info about the Perforce
        repository
        """

        if not self.util.check_install('p4 help'):
            return None

        data = self.util.execute(["p4", "info"], ignore_errors=True)

        m = re.search(r'^Server address: (.+)$', data, re.M)

        if not m:
            return None

        repository_path = m.group(1).strip()

        try:
            hostname, port = repository_path.split(":")
            info = socket.gethostbyaddr(hostname)

            # If aliases exist for hostname, create a list of alias:port
            # strings for repository_path.
            if info[1]:
                servers = [info[0]] + info[1]
                repository_path = ["%s:%s" % (server, port)
                                   for server in servers]
            else:
                repository_path = "%s:%s" % (info[0], port)

        except (socket.gaierror, socket.herror):
            pass

        m = re.search(r'^Server version: [^ ]*/([0-9]+)\.([0-9]+)/[0-9]+ .*$',
                      data, re.M)
        self.p4d_version = int(m.group(1)), int(m.group(2))

        return RepositoryInfo(path=repository_path, supports_changesets=True)

    def diff(self, args):
        """
        Goes through the hard work of generating a diff on Perforce in order
        to take into account adds/deletes and to provide the necessary
        revision information.
        """
        # set the P4 enviroment:
        #if options.p4_client:
        #   os.environ['P4CLIENT'] = options.p4_client

        #if options.p4_port:
        #   os.environ['P4PORT'] = options.p4_port

        changenum = self.get_changenum(args)

        if changenum is None:
            return self._path_diff(args)
        else:
            return self._changenum_diff(changenum)

    def get_changenum(self, args):

        if len(args) == 1:

            if args[0] == "default":
                return "default"

            try:
                return str(int(args[0]))
            except ValueError:
                pass
        return None

    def _do_diff(self, old_file, new_file, depot_path, base_revision, \
                 changetype_short, ignore_unmodified=False):
        """
        Do the work of producing a diff for Perforce.

        old_file - The absolute path to the "old" file.
        new_file - The absolute path to the "new" file.
        depot_path - The depot path in Perforce for this file.
        base_revision - The base perforce revision number of the old file as
            an integer.
        changetype_short - The change type as a single character string.
        ignore_unmodified - If True, will return an empty list if the file
            is not changed.

        Returns a list of strings of diff lines.
        """

        if hasattr(os, 'uname') and os.uname()[0] == 'SunOS':
            diff_cmd = ["gdiff", "-urNp", old_file, new_file]
        else:
            diff_cmd = ["diff", "-urNp", old_file, new_file]

        # Diff returns "1" if differences were found.
        dl = self.util.execute(diff_cmd, extra_ignore_errors=(1, 2), \
                     translate_newlines=False)

        # If the input file has ^M characters at end of line, lets ignore them.
        dl = dl.replace('\r\r\n', '\r\n')
        dl = dl.splitlines(True)

        cwd = os.getcwd()

        if depot_path.startswith(cwd):
            local_path = depot_path[len(cwd) + 1:]
        else:
            local_path = depot_path

        # Special handling for the output of the diff tool on binary files:
        #     diff outputs "Files a and b differ"
        # and the code below expects the output to start with
        #     "Binary files "
        if len(dl) == 1 and \
           dl[0].startswith('Files %s and %s differ' %
                            (old_file, new_file)):
            dl = ['Binary files %s and %s differ\n' % (old_file, new_file)]

        if dl == [] or dl[0].startswith("Binary files "):

            if dl == []:

                if ignore_unmodified:
                    return []
                else:
                    print "Warning: %s in your changeset is unmodified" % \
                        local_path

            dl.insert(0, "==== %s#%s ==%s== %s ====\n" % \
                (depot_path, base_revision, changetype_short, local_path))
            dl.append('\n')
        elif len(dl) > 1:
            m = re.search(r'(\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d)', dl[1])

            if m:
                timestamp = m.group(1)
            else:
                # Thu Sep  3 11:24:48 2007
                m = re.search( \
            r'(\w+)\s+(\w+)\s+(\d+)\s+(\d\d:\d\d:\d\d)\s+(\d\d\d\d)', dl[1])

                if not m:
                    self.util.die("Unable to parse diff header: %s" % dl[1])

                month_map = {
                    "Jan": "01",
                    "Feb": "02",
                    "Mar": "03",
                    "Apr": "04",
                    "May": "05",
                    "Jun": "06",
                    "Jul": "07",
                    "Aug": "08",
                    "Sep": "09",
                    "Oct": "10",
                    "Nov": "11",
                    "Dec": "12",
                }
                month = month_map[m.group(2)]
                day = m.group(3)
                timestamp = m.group(4)
                year = m.group(5)

                timestamp = "%s-%s-%s %s" % (year, month, day, timestamp)

            dl[0] = "--- %s\t%s#%s\n" % (local_path, depot_path, base_revision)
            dl[1] = "+++ %s\t%s\n" % (local_path, timestamp)

            # Not everybody has files that end in a newline (ugh). This ensures
            # that the resulting diff file isn't broken.

            if dl[-1][-1] != '\n':
                dl.append('\n')
        else:
            self.util.die("ERROR, no valid diffs: %s" % dl[0])

        return dl

    def _path_diff(self, args):
        """
        Process a path-style diff.  See _changenum_diff for the alternate
        version that handles specific change numbers.

        Multiple paths may be specified in `args`.  The path styles supported
        are:

        //path/to/file
        Upload file as a "new" file.

        //path/to/dir/...
        Upload all files as "new" files.

        //path/to/file[@#]rev
        Upload file from that rev as a "new" file.

        //path/to/file[@#]rev,[@#]rev
        Upload a diff between revs.

        //path/to/dir/...[@#]rev,[@#]rev
        Upload a diff of all files between revs in that directory.
        """
        r_revision_range = re.compile(r'^(?P<path>//[^@#]+)' +
                                      r'(?P<revision1>[#@][^,]+)?' +
                                      r'(?P<revision2>,[#@][^,]+)?$')

        empty_filename = util.make_tempfile()
        tmp_diff_from_filename = util.make_tempfile()
        tmp_diff_to_filename = util.make_tempfile()

        diff_lines = []

        for path in args:
            m = r_revision_range.match(path)

            if not m:
                self.util.die( \
                    'Path %r does not match a valid Perforce path.' % (path,))

            revision1 = m.group('revision1')
            revision2 = m.group('revision2')
            first_rev_path = m.group('path')

            if revision1:
                first_rev_path += revision1

            records = self._run_p4(['files', first_rev_path])

            # Make a map for convenience.
            files = {}

            # Records are:
            # 'rev': '1'
            # 'func': '...'
            # 'time': '1214418871'
            # 'action': 'edit'
            # 'type': 'ktext'
            # 'depotFile': '...'
            # 'change': '123456'
            for record in records:

                if record['action'] != 'delete':

                    if revision2:
                        files[record['depotFile']] = [record, None]
                    else:
                        files[record['depotFile']] = [None, record]

            if revision2:
                # [1:] to skip the comma.
                second_rev_path = m.group('path') + revision2[1:]
                records = self._run_p4(['files', second_rev_path])

                for record in records:

                    if record['action'] != 'delete':

                        try:
                            m = files[record['depotFile']]
                            m[1] = record
                        except KeyError:
                            files[record['depotFile']] = [None, record]

            old_file = new_file = empty_filename
            changetype_short = None

            for depot_path, (first_record, second_record) in files.items():
                old_file = new_file = empty_filename

                if first_record is None:
                    self._write_file(depot_path + '#' + second_record['rev'],
                                     tmp_diff_to_filename)
                    new_file = tmp_diff_to_filename
                    changetype_short = 'A'
                    base_revision = 0
                elif second_record is None:
                    self._write_file(depot_path + '#' + first_record['rev'],
                                     tmp_diff_from_filename)
                    old_file = tmp_diff_from_filename
                    changetype_short = 'D'
                    base_revision = int(first_record['rev'])
                elif first_record['rev'] == second_record['rev']:
                    # We when we know the revisions are the same, we don't need
                    # to do any diffing. This speeds up large revision-range
                    # diffs quite a bit.
                    continue
                else:
                    self._write_file(depot_path + '#' + first_record['rev'],
                                     tmp_diff_from_filename)
                    self._write_file(depot_path + '#' + second_record['rev'],
                                     tmp_diff_to_filename)
                    new_file = tmp_diff_to_filename
                    old_file = tmp_diff_from_filename
                    changetype_short = 'M'
                    base_revision = int(first_record['rev'])

                dl = self._do_diff(old_file, new_file, depot_path,
                                   base_revision, changetype_short,
                                   ignore_unmodified=True)
                diff_lines += dl

        os.unlink(empty_filename)
        os.unlink(tmp_diff_from_filename)
        os.unlink(tmp_diff_to_filename)
        return (''.join(diff_lines), None)

    def _changenum_diff(self, changenum):
        """
        Process a diff for a particular change number.  This handles both
        pending and submitted changelists.

        See _path_diff for the alternate version that does diffs of depot
        paths.
        """
        # TODO: It might be a good idea to enhance PerforceDiffParser to
        # understand that newFile could include a revision tag for post-submit
        # reviewing.
        cl_is_pending = False

        #debug("Generating diff for changenum %s" % changenum)

        description = []

        if changenum == "default":
            cl_is_pending = True
        else:
            description = self.util.execute(["p4", "describe", "-s", \
                                                changenum], split_lines=True)

            # Some P4 wrappers are addding an extra line before the description
            if '*pending*' in description[0] or '*pending*' in description[1]:
                cl_is_pending = True

        v = self.p4d_version

        if cl_is_pending and (v[0] < 2002 or (v[0] == "2002" and v[1] < 2)
                              or changenum == "default"):
            # Pre-2002.2 doesn't give file list in pending changelists,
            # or we don't have a description for a default changeset,
            # so we have to get it a different way.
            info = self.util.execute(["p4", "opened", "-c", str(changenum)],
                           split_lines=True)

            for line in info:
                data = line.split(" ")
                description.append("... %s %s" % (data[0], data[2]))

        else:

            # Get the file list
            for line_num, line in enumerate(description):

                if 'Affected files ...' in line:
                    break
                else:
                    # Got to the end of all the description lines and didn't
                    # find what we were looking for.
                    self.util.die( \
                        "Couldn't find any affected files for this change.")

            description = description[line_num + 2:]

        diff_lines = []

        empty_filename = make_tempfile()
        tmp_diff_from_filename = make_tempfile()
        tmp_diff_to_filename = make_tempfile()

        for line in description:
            line = line.strip()

            if not line:
                continue

            m = re.search(r'\.\.\. ([^#]+)#(\d+) '
                          r'(add|edit|delete|integrate|branch|move/add'
                          r'|move/delete)',
                          line)
            if not m:
                self.util.die("Unsupported line from p4 opened: %s" % line)

            depot_path = m.group(1)
            base_revision = int(m.group(2))

            if not cl_is_pending:
                # If the changelist is pending our base revision is the one
                # that's currently in the depot. If we're not pending the base
                # revision is actually the revision prior to this one
                base_revision -= 1

            changetype = m.group(3)

            #debug('Processing %s of %s' % (changetype, depot_path))

            old_file = new_file = empty_filename
            old_depot_path = new_depot_path = None
            changetype_short = None

            if changetype in ['edit', 'integrate']:
                # A big assumption
                new_revision = base_revision + 1

                # We have an old file, get p4 to take this old version from the
                # depot and put it into a plain old temp file for us
                old_depot_path = "%s#%s" % (depot_path, base_revision)
                self._write_file(old_depot_path, tmp_diff_from_filename)
                old_file = tmp_diff_from_filename

                # Also print out the new file into a tmpfile
                if cl_is_pending:
                    new_file = self._depot_to_local(depot_path)
                else:
                    new_depot_path = "%s#%s" % (depot_path, new_revision)
                    self._write_file(new_depot_path, tmp_diff_to_filename)
                    new_file = tmp_diff_to_filename

                changetype_short = "M"
            elif changetype in ['add', 'branch', 'move/add']:

                # We have a new file, get p4 to put this new file into a pretty
                # temp file for us. No old file to worry about here.
                if cl_is_pending:
                    new_file = self._depot_to_local(depot_path)
                else:
                    self._write_file(depot_path, tmp_diff_to_filename)
                    new_file = tmp_diff_to_filename

                changetype_short = "A"
            elif changetype in ['delete', 'move/delete']:
                # We've deleted a file, get p4 to put the deleted file into  a
                # temp file for us. The new file remains the empty file.
                old_depot_path = "%s#%s" % (depot_path, base_revision)
                self._write_file(old_depot_path, tmp_diff_from_filename)
                old_file = tmp_diff_from_filename
                changetype_short = "D"
            else:
                self.util.die("Unknown change type '%s' for %s" % ( \
                                                    changetype, depot_path))

            dl = self._do_diff(old_file, new_file, depot_path, \
                                base_revision, changetype_short)
            diff_lines += dl

        os.unlink(empty_filename)
        os.unlink(tmp_diff_from_filename)
        os.unlink(tmp_diff_to_filename)
        return (''.join(diff_lines), None)

    def _run_p4(self, command):
        """Execute a perforce command using the python marshal API.

        - command: A list of strings of the command to execute.

        The return type depends on the command being run.
        """
        command = ['p4', '-G'] + command
        p = subprocess.Popen(command, stdout=subprocess.PIPE)
        result = []
        has_error = False

        while 1:

            try:
                data = marshal.load(p.stdout)
            except EOFError:
                break
            else:
                result.append(data)
                if data.get('code', None) == 'error':
                    has_error = True

        rc = p.wait()

        if rc or has_error:

            for record in result:

                if 'data' in record:
                    print record['data']

            self.util.die('Failed to execute command: %s\n' % (command,))

        return result

    def sanitize_changenum(self, changenum):
        """
        Return a "sanitized" change number for submission to the Review Board
        server. For default changelists, this is always None. Otherwise, use
        the changelist number for submitted changelists, or if the p4d is
        2002.2 or newer.

        This is because p4d < 2002.2 does not return enough information about
        pending changelists in 'p4 describe' for Review Board to make use of
        them (specifically, the list of files is missing). This would result
        in the diffs being rejected.
        """

        if changenum == "default":
            return None
        else:
            v = self.p4d_version

            if v[0] < 2002 or (v[0] == "2002" and v[1] < 2):
                description = self.util.execute(["p4", "describe", "-s", \
                                                changenum], split_lines=True)

                if '*pending*' in description[0]:
                    return None

        return changenum

    def _depot_to_local(self, depot_path):
        """
        Given a path in the depot return the path on the local filesystem to
        the same file.  If there are multiple results, take only the last
        result from the where command.
        """
        where_output = self._run_p4(['where', depot_path])

        try:
            return where_output[-1]['path']
        except:
            # XXX: This breaks on filenames with spaces.
            return where_output[-1]['data'].split(' ')[2].strip()

    def _write_file(self, depot_path, tmpfile):
        """
        Grabs a file from Perforce and writes it to a temp file. p4 print sets
        the file readonly and that causes a later call to unlink fail. So we
        make the file read/write.
        """
        #debug('Writing "%s" to "%s"' % (depot_path, tmpfile))
        self.util.execute(["p4", "print", "-o", tmpfile, "-q", depot_path])
        os.chmod(tmpfile, stat.S_IREAD | stat.S_IWRITE)


class SVNRepository(Repository):
    """An implementation of Repository for SVN repositories"""

    def get_info(self):
        """Returns information about the repository
        
        This is an actual implementation that returns info about the SVN repo
        """

        if not self.util.check_install('svn help'):
            return None

        # Get the SVN repository path (either via a working copy or
        # a supplied URI)
        svn_info_params = ["svn", "info"]

        if self.url:
            svn_info_params.append(self.url)

        data = self.util.execute(svn_info_params,
                       ignore_errors=True)

        m = re.search(r'^Repository Root: (.+)$', data, re.M)

        if not m:
            return None

        path = m.group(1)

        m = re.search(r'^URL: (.+)$', data, re.M)

        if not m:
            return None

        base_path = m.group(1)[len(path):] or "/"

        m = re.search(r'^Repository UUID: (.+)$', data, re.M)

        if not m:
            return None

        # Now that we know it's SVN, make sure we have GNU diff installed,
        # and error out if we don't.
        check_gnu_diff()

        return SvnRepositoryInfo(path, base_path, m.group(1))

    def diff(self, files):
        """
        Performs a diff across all modified files in a Subversion repository.

        SVN repositories do not support branches of branches in a way that
        makes parent diffs possible, so we never return a parent diff
        (the second value in the tuple).
        """
        return (self.do_diff(["svn", "diff", "--diff-cmd=diff"] + files),
                None)

    def do_diff(self, cmd, repository_info=None):
        """
        Performs the actual diff operation, handling renames and converting
        paths to absolute.
        """
        diff = self.util.execute(cmd, split_lines=True)
        diff = self.handle_renames(diff)
        diff = self.convert_to_absolute_paths(diff, repository_info)

        return ''.join(diff)

    def handle_renames(self, diff_content):
        """
        The output of svn diff is incorrect when the file in question came
        into being via svn mv/cp. Although the patch for these files are
        relative to its parent, the diff header doesn't reflect this.
        This function fixes the relevant section headers of the patch to
        portray this relationship.
        """

        # svn diff against a repository URL on two revisions appears to
        # handle moved files properly, so only adjust the diff file names
        # if they were created using a working copy.
        if self.url:
            return diff_content

        result = []

        from_line = ""

        for line in diff_content:
            if line.startswith('--- '):
                from_line = line
                continue

            # This is where we decide how mangle the previous '--- '
            if line.startswith('+++ '):
                to_file, _ = self.parse_filename_header(line[4:])
                info = self.svn_info(to_file)

                if info.in("Copied From URL"):
                    self.url = info["Copied From URL"]
                    root = info["Repository Root"]
                    from_file = urllib.unquote(url[len(root):])
                    result.append(from_line.replace(to_file, from_file))
                else:
                    result.append(from_line)  # as is, no copy performed

            # We only mangle '---' lines. All others get added straight to
            # the output.
            result.append(line)

        return result

    def svn_info(self, path):
        """Return a dict which is the result of 'svn info' at a given path."""
        svninfo = {}

        for info in self.util.execute(["svn", "info", path],
                            split_lines=True):
            parts = info.strip().split(": ", 1)

            if len(parts) == 2:
                key, value = parts
                svninfo[key] = value

        return svninfo

            # Adapted from server code parser.py
    def parse_filename_header(self, s):
        parts = None

        if "\t" in s:
            # There's a \t separating the filename and info. This is the
            # best case scenario, since it allows for filenames with spaces
            # without much work. The info can also contain tabs after the
            # initial one; ignore those when splitting the string.
            parts = s.split("\t", 1)

        # There's spaces being used to separate the filename and info.
        # This is technically wrong, so all we can do is assume that
        # 1) the filename won't have multiple consecutive spaces, and
        # 2) there's at least 2 spaces separating the filename and info.
        if "  " in s:
            parts = re.split(r"  +", s)

        if parts:
            parts[1] = '\t' + parts[1]
            return parts

        # strip off ending newline, and return it as the second component
        return [s.split('\n')[0], '\n']

    def convert_to_absolute_paths(self, diff_content, repository_info):
        """
        Converts relative paths in a diff output to absolute paths.
        This handles paths that have been svn switched to other parts of the
        repository.
        """

        result = []

        for line in diff_content:
            front = None

            if line.startswith('+++ ') or line.startswith('--- ') or \
                                            line.startswith('Index: '):
                front, line = line.split(" ", 1)

            if front:

                if line.startswith('/'):  # already absolute
                    line = front + " " + line
                else:
                    # filename and rest of line (usually the revision
                    # component)
                    file, rest = self.parse_filename_header(line)

                    # If working with a diff generated outside of a working
                    # copy, then file paths are already absolute, so just
                    # add initial slash.
                    if self.url:
                        path = urllib.unquote(
                            "%s/%s" % (repository_info.base_path, file))
                    else:
                        info = self.svn_info(file)
                        self.url = info["URL"]
                        root = info["Repository Root"]
                        path = urllib.unquote(url[len(root):])

                    line = front + " " + path + rest

            result.append(line)

        return result


class RepositoryInfo:
    """A representation of a source code repository."""

    def __init__(self, path=None, base_path=None, supports_changesets=False,
                 supports_parent_diffs=False):
        self.path = path
        self.base_path = base_path
        self.supports_changesets = supports_changesets
        self.supports_parent_diffs = supports_parent_diffs
        #debug("repository info: %s" % self)

    def __str__(self):
        return "Path: %s, Base path: %s, Supports changesets: %s" % \
            (self.path, self.base_path, self.supports_changesets)

    def set_base_path(self, base_path):

        if not base_path.startswith('/'):
            base_path = '/' + base_path
        #debug("changing repository info base_path from %s to %s" % \
        #      (self.base_path, base_path))
        self.base_path = base_path

    def find_server_repository_info(self, server):
        """
        Try to find the repository from the list of repositories on the server.
        For Subversion, this could be a repository with a different URL. For
        all other clients, this is a noop.
        """
        return self


class SvnRepositoryInfo(RepositoryInfo):
    """
    A representation of a SVN source code repository. This version knows how to
    find a matching repository on the server even if the URLs differ.
    """

    def __init__(self, path, base_path, uuid, supports_parent_diffs=False):
        RepositoryInfo.__init__(self, path, base_path,
                                supports_parent_diffs=supports_parent_diffs)
        self.uuid = uuid

    def find_server_repository_info(self, server):
        """
        The point of this function is to find a repository on the server that
        matches self, even if the paths aren't the same. (For example, if self
        uses an 'http' path, but the server uses a 'file' path for the same
        repository.) It does this by comparing repository UUIDs. If the
        repositories use the same path, you'll get back self, otherwise you'll
        get a different SvnRepositoryInfo object (with a different path).
        """
        repositories = server.get_repositories()

        for repository in repositories:

            if repository['tool'] != 'Subversion':
                continue

            info = self._get_repository_info(server, repository)

            if not info or self.uuid != info['uuid']:
                continue

            repos_base_path = info['url'][len(info['root_url']):]
            relpath = self._get_relative_path(self.base_path, repos_base_path)

            if relpath:
                return SvnRepositoryInfo(info['url'], relpath, self.uuid)

        # We didn't find a matching repository on the server. We'll just return
        # self and hope for the best.
        return self

    def _get_repository_info(self, server, repository):

        try:
            return server.get_repository_info(repository['id'])
        except APIError, e:
            # If the server couldn't fetch the repository info, it will return
            # code 210. Ignore those.
            # Other more serious errors should still be raised, though.

            if e.error_code == 210:
                return None

            raise e

    def _get_relative_path(self, path, root):
        pathdirs = self._split_on_slash(path)
        rootdirs = self._split_on_slash(root)

        # root is empty, so anything relative to that is itself
        if len(rootdirs) == 0:
            return path

        # If one of the directories doesn't match, then path is not relative
        # to root.
        if rootdirs != pathdirs:
            return None

        # All the directories matched, so the relative path is whatever
        # directories are left over. The base_path can't be empty, though, so
        # if the paths are the same, return '/'
        if len(pathdirs) == len(rootdirs):
            return '/'
        else:
            return '/'.join(pathdirs[len(rootdirs):])

    def _split_on_slash(self, path):
        # Split on slashes, but ignore multiple slashes and throw away any
        # trailing slashes.
        split = re.split('/*', path)

        if split[-1] == '':
            split = split[0:-1]
        return split
